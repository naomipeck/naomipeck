<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introduction to Fieldwork: From elicitation to ELAN</title>
    <meta charset="utf-8" />
    <meta name="author" content="Naomi Peck" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
    <link href="libs/countdown/countdown.css" rel="stylesheet" />
    <script src="libs/countdown/countdown.js"></script>
  </head>
  <body>
    <textarea id="source">

class: inverse, center, middle



# Introduction to Fieldwork: From elicitation to ELAN &lt;br&gt;
## Session 3: Introduction to ELAN &amp;nbsp;

## Naomi Peck &amp;nbsp;

### Albert-Ludwigs-Universität Freiburg &lt;br&gt; 2022-02-12 (updated: 2022-02-12)
&amp;nbsp;

&lt;img src="freiburg-logo.png" height="125px"/&gt;

&lt;!-- insert VJS logo too? figure this out --&gt;


---

class: middle, center

# Why ELAN?

---

# Why ELAN?

ELAN allows researchers to directly work with audiovisual data. &lt;br&gt;&lt;br&gt;

--

ELAN supports multiple levels of annotation. &lt;br&gt;&lt;br&gt;

--

ELAN enables both qualitative and quantitative research.

---

class: center, middle

# ELAN Interface

---

class: center, middle

&lt;div style="position: relative; padding-bottom: 56.25%; height: 0;"&gt;&lt;iframe src="https://www.loom.com/embed/721ce9dba3fd4dc39beb81a31de1c986" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"&gt;&lt;/iframe&gt;&lt;/div&gt;

---

# Modes

- Annotation Mode

- Media Synchronization Mode

- Segmentation Mode

- Transcription Mode

- Interlinearization Mode

---

label: media-sync
class: center, middle

&lt;div style="position: relative; padding-bottom: 56.25%; height: 0;"&gt;&lt;iframe src="https://www.loom.com/embed/3856556266764e02aa3ab667d47431cc" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"&gt;&lt;/iframe&gt;&lt;/div&gt;

---

label: segmentation
class: center, middle

&lt;div style="position: relative; padding-bottom: 56.25%; height: 0;"&gt;&lt;iframe src="https://www.loom.com/embed/f42af26bdfe843ec9703890304c5ecd2" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"&gt;&lt;/iframe&gt;&lt;/div&gt;

---

label: transcription
class: center, middle

&lt;div style="position: relative; padding-bottom: 56.25%; height: 0;"&gt;&lt;iframe src="https://www.loom.com/embed/67726e1a877e441ab79e99b87b57324c" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"&gt;&lt;/iframe&gt;&lt;/div&gt;

---

label: interlinear
class: center, middle

&lt;div style="position: relative; padding-bottom: 56.25%; height: 0;"&gt;&lt;iframe src="https://www.loom.com/embed/1c5018f22f2f4a4b8c70c912b3a88789" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"&gt;&lt;/iframe&gt;&lt;/div&gt;

---

class: center, middle

# Tiers and Types

---

# Tiers and Types

Tiers and types are possibly the most complicated part about learning to use ELAN. Having a good understanding of how these relate to each other will help you in your journey to master ELAN immensely.

Simply put, (tier) types provide a template for what kind of annotations you want to make, and how annotations will relate to each other. Tiers are the “physical” places where these annotations are made.

Always make sure to set up your tier types before creating your tiers.

---

class: center, middle

&lt;div style="position: relative; padding-bottom: 56.25%; height: 0;"&gt;&lt;iframe src="https://www.loom.com/embed/d4758e2d9c354385bea8a545c757e805" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"&gt;&lt;/iframe&gt;&lt;/div&gt;

---

# Tier Types

All tier types must minimally have a name. 

If you want to create dependent tiers (“children”), then you must select a stereotype. 

These stereotypes differ primarily depending on whether the child will be time-aligned or symbolically-aligned.

You can also limit what values annotations can have using a controlled vocabulary, and associate types with lexicon and data categories.

---

# Which tier type do I need?

Question 1: Are my annotations dependent or independent?

--

Yes -&gt; No tier type needed.

--

No -&gt; Q2.

--

Annotations on an independent tier make *direct* reference to the audiovisual tracks.

---

# Which tier type do I need?

Question 2: Should my annotations be time-aligned or symbolically-aligned?

---

# Time-aligned.

-&gt; Q3.

--

Question 3: Do I want gaps in between my annotations?

--

Yes -&gt; Included In

--

No -&gt; Time Subdivision

--

*Time-aligned* annotations are useful if you want to tie smaller annotations, e.g. words or IUs within utterances, to the audio track.

Time-aligned annotations (including on independent tiers) are by default outlined in black.

---

# Symbolically-aligned.

-&gt; Q4.

--

Question 4: Should my annotations have a one-to-one or a one-to-many relation with the superordinate tier?

--

One-to-one -&gt; Symbolic Association

--

One-to-many -&gt; Symbolic Subdivision

--

*Symbolic* associations are useful for secondary annotations. For example, Symbolic Association tiers are commonly used for part of speech glossing and Symbolic Subdivision tiers are commonly used for word or morpheme annotations.

Symbolic annotations are outlined in default in yellow.

---

class: middle, center

# Creating Tiers

---

class: middle, center

&lt;div style="position: relative; padding-bottom: 56.25%; height: 0;"&gt;&lt;iframe src="https://www.loom.com/embed/8643ae2c99ee431b8a072244d229c74b" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"&gt;&lt;/iframe&gt;&lt;/div&gt;

---

# Tier Naming Coventions

Each tier name should minimally consist of a code for the data type, a separator character (gen. @ or _), and a participant code.

Different people and programs have a range of conventions about how naming should be done. Make sure to double-check if a certain format is required for programs and archives etc..

Minimally, names should make it obvious to anyone accessing the file which tier contains what type of data and who produced which data.

.center[
##datatype@participant
]


---

# Further Tools

ELAN is always under further development. As such, new functions are being added all the time, which you may or may not be aware of.

.pull-left[
-   Advanced search capabilities

    -   constraints
    -   full regex support
    -   export search results

-   Multiple file search

    -   multiple find and replace also available!

-   Inter-annotator reliability
-   Spell-checking (requires language specification of tiers)
]

.pull-right[
-   Multiple file processing
    
    -   creating multiple new files from pre-existing transcriptions
    -   batch cleaning, editing, exporting
    -   statistics across multiple files

-   Third party programming packages

    -   pympi
    -   phonfieldwork
]

---

# Further Sources

ELAN Manual: https://archive.mpi.nl/tla/elan/documentation

If you are having any issues, their support team is incredibly helpful: https://archive.mpi.nl/forums/c/elan

Lots of people have created resources for you to learn how to use ELAN and a simple Google search will bring up many of them. Some I recommend are:

Ulrike Mosel’s guide on regex searching: [Searches with Regular Expressions in ELAN corpora](https://www.isfas.uni-kiel.de/de/linguistik/mitarbeitende/prof.-dr.-ulrike-mosel/publications_mosel/elan-regular-expressions) 

Hedvig Skirgard’s guide for speeding up the transcription workflow: [My ELAN workflow for segmenting and transcription](http://humans-who-read-grammars.blogspot.com/2019/07/my-elan-workflow-for-segmenting-and.html)

John Mansfield’s guide on the ELAN-FLEx workflow: [Elan - Flex workflow](http://langwidj.org/linguistics/elan-flex-workflow/) 

Amalia Skilton’s scripts and guides: [ELAN Scripts](https://blogs.cornell.edu/amaliaskilton/elan-scripts/) 

Eri Kashima and T. Mark Ellison’s Praat to ELAN workflow: [Elan/Praat Machine Segmenting](https://yammeringon.wordpress.com/2017/05/01/elanpraat-machine-segmenting/)

---

class: inverse, center, middle

# Short Break 

<div class="countdown" id="timer_62079bdd" style="right:34%;bottom:20%;" data-audio="true" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">05</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
